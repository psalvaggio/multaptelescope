// File Description
// Author: Philip Salvaggio

#include "envi_image_writer.h"
#include "io/logging.h"
#include "base/str_utils.h"
#include <fstream>


using namespace cv;
using namespace std;

namespace mats_io {

EnviImageWriter::EnviImageWriter() {}

// Fully-specified Write method. Call this one if the header file does not
// follow the naming convention above
bool EnviImageWriter::Write(const std::string& image_filename,
                            const std::string& header_filename,
                            EnviImageHeader* hdr,
                            const std::vector<cv::Mat>& image) {
  if (!hdr || image.size() == 0) return false;

  hdr->set_lines(image[0].rows);
  hdr->set_samples(image[0].cols);
  hdr->set_bands(image.size());

  if (hdr->band_size() != hdr->bands()) {
    for (int i = hdr->band_size(); i < hdr->bands(); i++) {
      EnviBand* new_band = hdr->add_band();
      new_band->set_name(mats::StringPrintf("Band %d", i));
      new_band->set_center_wavelength(0);
      new_band->set_fwhm(0);
      new_band->set_bad_band_multiplier(1);
    }
  }

  int depth;
  int envi_type = GetEnviDType(image[0].type(), depth);
  if (envi_type == -1) return false;
  hdr->set_data_type(envi_type);

  const size_t kSize = hdr->lines() * hdr->samples() * hdr->bands() * depth;

  if (hdr->bands() <= 0 || hdr->samples() <= 0 || hdr->lines() <= 0) {
    mainLog() << "Error: Invalid image dimensions in ENVI header." << endl;
    return false;
  }

  if (!hdr->has_byte_order()) {
    mainLog() << "Warning: No byte order given in ENVI header. Assuming 0."
              << endl;
    hdr->set_byte_order(0);
  }

  if (!hdr->has_interleave_type()) {
    mainLog() << "Warning: No interleave type giving, assuming BIL" << endl;
    hdr->set_interleave_type(EnviImageHeader::BIL);
  }

  if (!hdr->has_data_type()) {
    mainLog() << "Error: ENVI header missing data type." << endl;
    return false;
  }

  if (!WriteHeader(header_filename, *hdr)) {
    mainLog() << "Error: Could not write ENVI header file \""
              << header_filename << "\"" << endl;
    return false;
  }

  FILE* img_file = fopen(image_filename.c_str(), "wb");
  if (!img_file) {
    mainLog() << "Can not open image file \"" << image_filename << "\"" << endl;
    return false;
  }

  if (hdr->header_offset() != 0) {
    uint8_t* buffer = new uint8_t[hdr->header_offset()];
    fwrite(buffer, sizeof(uint8_t), hdr->header_offset(), img_file);
    delete[] buffer;
  }

  uint8_t* raw_data = new uint8_t[kSize];
  switch (envi_type) {
    case EnviImageHeader::BYTE8:
      RearrangeImageData(image, *hdr, raw_data); break;
    case EnviImageHeader::INT16:
      RearrangeImageData(image, *hdr, (int16_t*)raw_data); break;
    case EnviImageHeader::INT32:
      RearrangeImageData(image, *hdr, (int32_t*)raw_data); break;
    case EnviImageHeader::FLOAT32:
      RearrangeImageData(image, *hdr, (float*)raw_data); break;
    case EnviImageHeader::FLOAT64:
      RearrangeImageData(image, *hdr, (double*)raw_data); break;
  }

  if (fwrite(raw_data, 1, kSize, img_file) != kSize) {
    mainLog() << "Could not write image data to the output file." << endl;
    delete[] raw_data;
    fclose(img_file);
    return false;
  }

  delete[] raw_data;
  fclose(img_file);
  return true;
}

bool EnviImageWriter::WriteHeader(const std::string& header_filename,
                                  const EnviImageHeader& hdr) {
  ofstream out(header_filename.c_str());
  if (!out.is_open()) return false;

  out << "ENVI" << endl
      << "description = {Generated by DIRSIG}" << endl
      << "samples = " << hdr.samples() << endl
      << "lines = " << hdr.lines() << endl
      << "bands = " << hdr.bands() << endl
      << "header offset = " << hdr.header_offset() << endl
      << "file type = " << hdr.file_type() << endl
      << "data type = " << hdr.data_type() << endl
      << "interleave = ";

  switch (hdr.interleave_type()) {
    case EnviImageHeader::BSQ: out << "bsq"; break;
    case EnviImageHeader::BIP: out << "bip"; break;
    case EnviImageHeader::BIL: out << "bil"; break;
  }

  out << endl
      << "sensor type = " << hdr.sensor_type() << endl
      << "byte order = " << hdr.byte_order() << endl
      << "x start = " << hdr.start_x() << endl
      << "y start = " << hdr.start_y() << endl
      << "wavelength units = " << hdr.wavelength_units() << endl
      << "map info = " << hdr.map_info() << endl
      << "projection info = " << hdr.projection_info() << endl
      << "default bands = " << hdr.default_bands() << endl
      << "default stretch = " << hdr.default_stretch() << endl
      << "z plot range = " << hdr.z_plot_range() << endl
      << "z plot titles = " << hdr.z_plot_titles() << endl
      << "z plot average = " << hdr.z_plot_average() << endl;

  stringstream wavelength, band_names, fwhm, bbl;
  for (int i = 0; i < hdr.band_size(); i++) {
    wavelength.precision(6);
    wavelength << " " << hdr.band(i).center_wavelength();
    band_names << " " << hdr.band(i).name();
    fwhm.precision(6);
    fwhm << " " << hdr.band(i).fwhm();
    bbl << " " << hdr.band(i).bad_band_multiplier();

    if (i != hdr.band_size() - 1) {
      wavelength << ",";
      band_names << ",";
      fwhm << ",";
      bbl << ",";

      if (i % 7 == 0) {
        wavelength << endl;
        fwhm << endl;
      }
    }
  }

  out << "band names = {" << endl << band_names.str() << "}" << endl
      << "wavelength = {" << endl << wavelength.str() << "}" << endl
      << "fwhm = {" << endl << fwhm.str() << "}" << endl
      << "bbl = {" << endl << bbl.str() << "}" << endl;

  return true;
}

int EnviImageWriter::GetEnviDType(int opencv_dtype, int& size) {
  switch (opencv_dtype) {
    case CV_8UC1: size = 1; return EnviImageHeader::BYTE8;
    case CV_16SC1: size = 2; return EnviImageHeader::INT16;
    case CV_32SC1: size = 4; return EnviImageHeader::INT32;
    case CV_32FC1: size = 4; return EnviImageHeader::FLOAT32;
    case CV_64FC1: size = 8; return EnviImageHeader::FLOAT64;
    case CV_32FC2:
    case CV_64FC2:
      mainLog() << "Error: Complex inputs not yet supported." << endl;
      break;
    case CV_16UC1: size = 2; return EnviImageHeader::UINT16;
    default:
      mainLog() << "Error: Unsupported OpenCV data type." << endl;
      break;
  }

  return -1;
}

}
